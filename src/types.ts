/**
 * Type extensions for Macrodata
 *
 * Base Env is generated by `wrangler types` from wrangler.jsonc + .dev.vars
 * We augment Cloudflare.Env with runtime-injected bindings.
 */

import type { OAuthHelpers } from "@cloudflare/workers-oauth-provider";

declare global {
	namespace Cloudflare {
		interface Env {
			OAUTH_PROVIDER: OAuthHelpers;
		}
	}
}

// ==========================================
// Core Context Types
// ==========================================

/** Core context file identifiers */
export type CoreContextType = "identity" | "today" | "human";

/** Core context row from SQLite */
export type CoreContextRow = {
	which: CoreContextType;
	content: string;
	updated_at: string;
};

// ==========================================
// Knowledge Types
// ==========================================

/** Knowledge entry row from SQLite */
export type KnowledgeRow = {
	id: string;
	type: string;
	name: string;
	content: string;
	tags: string | null; // JSON array
	created_at: string;
	updated_at: string;
};

/** Knowledge entry for API responses */
export type Knowledge = {
	id: string;
	type: string;
	name: string;
	content: string;
	tags: string[];
	createdAt: string;
	updatedAt: string;
};

// ==========================================
// Journal Types
// ==========================================

/** Journal entry row from SQLite */
export type JournalRow = {
	id: string;
	topic: string;
	content: string;
	intent: string | null;
	timestamp: string;
};

/** Journal entry for API responses */
export type JournalEntry = {
	id: string;
	topic: string;
	content: string;
	intent?: string;
	timestamp: string;
};

// ==========================================
// Query Types
// ==========================================

/** Vectorize metadata stored with embeddings */
export type VectorMetadata = {
	type: "journal" | "knowledge" | "summary" | "core";
	subtype?: string; // For knowledge: the knowledge type
	name?: string;
	topic?: string;
	timestamp: number; // Unix timestamp for range filtering
	content: string;
};

/** Query result from memory search */
export interface QueryResult {
	id: string;
	type: string;
	subtype?: string;
	topic?: string;
	name?: string;
	content: string;
	score?: number;
	timestamp: string;
}

/** Query parameters for query_memory */
export interface QueryParams {
	query?: string;
	type?: "journal" | "knowledge" | "summary" | "core" | "all";
	knowledgeType?: string;
	topic?: string;
	since?: string; // ISO date
	until?: string; // ISO date
	limit?: number;
	offset?: number;
}

// ==========================================
// Memory Stats Types
// ==========================================

/** Memory statistics response */
export interface MemoryStats {
	journal: {
		count: number;
		oldest: string | null;
		newest: string | null;
	};
	knowledge: {
		total: number;
		byType: Record<string, number>;
	};
	summaries: {
		count: number;
	};
	core: {
		identity: boolean;
		today: boolean;
		human: boolean;
	};
}

// ==========================================
// External MCP Types
// ==========================================

/** Connected external MCP server */
export interface ConnectedMcp {
	name: string;
	endpoint: string;
	accessToken: string;
	refreshToken?: string;
	tokenExpiresAt?: number;
	connectedAt: string;
}

/** MCP tool definition */
export interface McpTool {
	name: string;
	description?: string;
	inputSchema?: Record<string, unknown>;
}
